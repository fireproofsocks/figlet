defmodule Figlet.Parser.FontFileParser do
  @moduledoc """
  This module parses figlet font files identified by the path to the file.

  A FIGlet file has 3 main parts:

  - Headerline
  - Comments
  - Character Data



  ## [FIGcharacter Data](http://www.jave.de/figlet/figfont.html#figcharacterdata)

  The FIGcharacter data begins on the next line after the comments and continues
  to the end of the file.

  ## Basic Data Structure

  The sub-characters in the file are given exactly as they should be output, with
  two exceptions:

  1. Hardblanks should be the hardblank character specified in the header line, not a blank (space).
  2. Every line has one or two endmark characters, whose column locations define the width of each FIGcharacter.

  In most FIGfonts, the endmark character is either "@" or "#". The FIGdriver will
  eliminate the last block of consecutive equal characters from each line of
  sub-characters when the font is read in. By convention, the last line of a
  FIGcharacter has two endmarks, while all the rest have one. This makes it easy
  to see where FIGcharacters begin and end. No line should have more than two endmarks.

  ## See Also

  Building a parser for Figlet files would be practically impossible without a useful spec for
  reference. Relevant links for the Figlet font file spec:

  - http://www.jave.de/docs/figfont.txt
  - https://github.com/Marak/asciimo/issues/3
  """

  alias Figlet.{Char, Font, Meta}
  alias Figlet.Parser.HeaderlineParser

  @reqd_codepoints Enum.concat(32..126, [196, 214, 220, 228, 246, 252, 223])

  defmodule Error do
    @moduledoc false
    defexception message: "parser error"
  end

  if Version.compare(System.version(), "1.16.0") in [:gt, :eq] do
    defp stream_file!(path, line_or_bytes_modes), do: File.stream!(path, line_or_bytes_modes)
  else
    defp stream_file!(path, line_or_bytes), do: File.stream!(path, [], line_or_bytes)
  end

  @doc """
  Parses the Figlet font file at the given absolute `filepath`, returning a `%Figlet.Font{}`
  struct.

  Given:
  `flf2a 4 3 8 15 11 0 10127`

  The 6th character (the invisible one after the `a`) is a unicode value for "hardBlank"

  All FIGlet fonts must contain chars 32-126, 196, 214, 220, 228, 246, 252, 223
  """
  def parse(filepath, opts \\ [])

  def parse(filepath, _opts) when is_binary(filepath) do
    Logger.metadata(font: filepath)

    case File.exists?(filepath) do
      true ->
        filepath
        |> stream_file!(:line)
        |> Enum.reduce({:headerline, %Font{source: filepath}}, &parse_line/2)
        |> case do
          {:chardata, _, font, _, _} -> {:ok, font}
          _other -> {:error, "Something else happened"}
        end

      false ->
        {:error, "File not found: #{inspect(filepath)}"}
    end
  rescue
    error in Figlet.Parser.FileParser.Error -> {:error, "#{filepath}: #{inspect(error)}"}
  end

  # acc: {<task>, tmp_acc, %Font{}, line_i}
  # acc: {:comments, tmp_acc, font, line_i}
  defp parse_line(header, {:headerline, font}) do
    case HeaderlineParser.parse(header) do
      {:ok, meta} ->
        {:comments, "", Map.put(font, :meta, meta), 2}

      {:error, error} ->
        raise Error, message: error
    end
  end

  # After the headerline, accumulate comments
  defp parse_line(
         line,
         {:comments, comment_acc, %Font{meta: %Meta{comment_lines: comment_lines}} = font, line_i}
       )
       when line_i <= comment_lines do
    {:comments, comment_acc <> line, font, line_i + 1}
  end

  # Final comment line / transition to chardata
  defp parse_line(
         line,
         {:comments, comment_acc, %Font{} = font, _line_i}
       ) do
    [codepoint | rem_codepoints] = @reqd_codepoints

    {:chardata, %Char{codepoint: codepoint}, Map.put(font, :comments, comment_acc <> line),
     rem_codepoints, 1}
  end

  # After the comments, accumulate the chardata
  # http://www.jave.de/figlet/figfont.html#figcharacterdata
  defp parse_line(
         line,
         {:chardata, char, %Font{meta: %{height: height}} = font, rem_codepoints, line_i}
       )
       when line_i < height do
    updated_char =
      update_in(char.slices, fn slices -> Map.put(slices, line_i, trim_endmarks(line)) end)

    {:chardata, updated_char, font, rem_codepoints, line_i + 1}
  end

  # last line of the char
  defp parse_line(
         line,
         {:chardata, char, %Font{meta: %{height: height}} = font,
          [new_codepoint | rem_codepoints], line_i}
       )
       when line_i == height do
    line_data = trim_endmarks(line)

    updated_char =
      update_in(char.slices, fn slices -> Map.put(slices, line_i, line_data) end)
      |> Map.put(:width, String.length(line_data))

    updated_font =
      update_in(font.char_map, fn char_map -> Map.put(char_map, char.codepoint, updated_char) end)

    {:chardata, %Char{codepoint: new_codepoint}, updated_font, rem_codepoints, 1}
  end

  # TODO: ad-hoc chars
  defp parse_line(_line, acc) do
    acc
  end

  # In most FIGfonts, the endmark character is either "@" or "#", but
  # we assume it is the character that _precedes_ the newline.
  defp trim_endmarks(line_acc) do
    line_acc = String.trim_trailing(line_acc, "\n")
    endmark = String.last(line_acc)
    String.trim_trailing(line_acc, endmark)
  end
end
